<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>My Repair Shop Calendar</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
    body { padding: 20px; background: #f8f9fa; font-family: Arial, sans-serif; }
    .day-header { font-weight: bold; background: #343a40; color: white; text-align: center; padding: 10px; }
    .time-label { background: #e9ecef; font-weight: bold; text-align: right; padding-right: 15px; vertical-align: middle !important; }
    .section-label { background: #d4edda; font-size: 1.1em; font-weight: bold; color: #155724; }
    .time-slot { min-height: 90px; border: 1px solid #ddd; padding: 6px; position: relative; cursor: pointer; transition: background 0.2s; }
    .time-slot:hover { background: #f1f8ff; }
    .appt { padding: 8px; margin: 4px 0; border-radius: 8px; color: white; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
    .green { background: #28a745; }
    .yellow { background: #ffc107; color: #212529; }
    .red { background: #dc3545; }
    .closed { background: #6c757d; color: white; text-align: center; padding-top: 35px; font-size: 1.2em; }
    .today { background: #fff3cd !important; border: 3px solid #ffc107 !important; }
    #installBtn { display:none; margin-left:10px; }
    </style>
</head>
<body>
<div id="clock" style="position:fixed; top:10px; left:10px; font-size:20px; font-weight:bold;"></div>
<div class="container">
    <h1 class="text-center mb-4 text-primary">My Car Repair Shop Calendar</h1>

    <div class="text-center mb-4" id="controlsRow">
        <button class="btn btn-outline-primary" id="prev">← Prev Week</button>
        <button class="btn btn-primary mx-3" id="today">Today</button>
        <button class="btn btn-outline-primary" id="next">Next Week →</button>
        <button class="btn btn-success ms-4" id="backup">Backup Data</button>
        <button class="btn btn-info" id="restoreBtn">Restore</button>
        <button class="btn btn-secondary" id="installBtn">Install App</button>
        <input type="file" id="restore" style="display:none;" accept=".json">
    </div>

    <div id="weekInfo" class="text-center fs-4 mb-3 text-muted"></div>
    <div class="table-responsive">
        <table class="table table-bordered align-middle" id="calendar">
            <thead></thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<!-- Modal -->
<div class="modal fade" id="apptModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header bg-primary text-white">
                <h5 class="modal-title">Appointment</h5>
                <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editId">
                <div class="mb-3">
                    <label class="form-label">Customer Name *</label>
                    <input type="text" class="form-control" id="name" placeholder="e.g. Rajesh Sharma">
                </div>
                <div class="mb-3">
                    <label class="form-label">Phone / Car Details</label>
                    <input type="text" class="form-control" id="details"
                           placeholder="e.g. 9876543210 | Swift DZire UP32AB1234">
                </div>
                <div class="row">
                    <div class="col-6">
                        <label class="form-label">Start Time *</label>
                        <input type="time" class="form-control" id="start" required>
                    </div>
                    <div class="col-6">
                        <label class="form-label">End Time *</label>
                        <input type="time" class="form-control" id="end" required>
                    </div>
                </div>
                <small class="text-muted">Default duration = 1 hour. You can change freely.</small>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-danger" id="deleteBtn" style="display:none;">Delete</button>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="saveBtn">Save Appointment</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
<script>
/* =======================
   IndexedDB wrapper (safe upgrade)
   ======================= */
const db = {
  async init() {
    if (this.db) return;
    return new Promise((res, rej) => {
      const req = indexedDB.open('RepairShop', 2);
      req.onupgradeneeded = e => {
        const idb = e.target.result;
        // SAFE: create only if not exists
        if (!idb.objectStoreNames.contains('appts')) {
          idb.createObjectStore('appts', { keyPath: 'id', autoIncrement: true });
        }
      };
      req.onsuccess = e => { this.db = e.target.result; res(); };
      req.onerror = rej;
    });
  },
  async getAll() { await this.init(); return new Promise(res => this.db.transaction('appts').objectStore('appts').getAll().onsuccess = e => res(e.target.result)); },
  async add(o) { await this.init(); return new Promise((res, rej) => { const tx = this.db.transaction('appts','readwrite'); const store = tx.objectStore('appts'); const r = store.add(o); r.onsuccess = () => {}; r.onerror = rej; tx.oncomplete = res; tx.onerror = rej; }); },
  async put(o) { await this.init(); return new Promise((res, rej) => { const tx = this.db.transaction('appts','readwrite'); const store = tx.objectStore('appts'); const r = store.put(o); r.onsuccess = () => {}; r.onerror = rej; tx.oncomplete = res; tx.onerror = rej; }); },
  async delete(id) { await this.init(); return new Promise(res => { const tx = this.db.transaction('appts','readwrite'); tx.objectStore('appts').delete(id); tx.oncomplete = res; }); },
  async clear() { await this.init(); return new Promise(res => { const tx = this.db.transaction('appts','readwrite'); tx.objectStore('appts').clear(); tx.oncomplete = res; }); }
};

const weekDays = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
let currentMonday = getMonday(new Date());
let deferredInstallPrompt = null;

function getMonday(d) {
  d = new Date(d);
  const day = d.getDay();
  const diff = d.getDate() - day + (day === 0 ? -6 : 1);
  return new Date(d.setDate(diff));
}
function formatDate(d) { return d.toLocaleDateString('en-IN', { day:'2-digit', month:'short', year:'numeric' }); }
function isToday(d) { return d.toDateString() === new Date().toDateString(); }

function renderCalendar() {
  const thead = document.querySelector('#calendar thead');
  const tbody = document.querySelector('#calendar tbody');
  thead.innerHTML = ''; tbody.innerHTML = '';
  document.getElementById('weekInfo').textContent = `${formatDate(currentMonday)} – ${formatDate(new Date(currentMonday.getTime() + 6*24*60*60*1000))}`;

  // Header row
  let header = '<tr><th></th>';
  for (let i = 0; i < 7; i++) {
    const date = new Date(currentMonday); date.setDate(date.getDate() + i);
    const cls = isToday(date) ? 'today day-header' : 'day-header';
    header += `<th class="${cls}">${weekDays[date.getDay()]}<br>${date.getDate()}</th>`;
  }
  header += '</tr>';
  thead.innerHTML = header;

  // Time slots with sections
  const sections = [
    { label: "MORNING", start: 9, end: 12 },
    { label: "AFTERNOON", start: 12, end: 15 },
    { label: "EVENING", start: 15, end: 19 }
  ];

  sections.forEach(sec => {
    // Section label row
    let row = `<tr><td class="section-label text-center">${sec.label}</td>`;
    for (let d = 0; d < 7; d++) row += (new Date(currentMonday.getTime() + d*24*60*60*1000).getDay() === 0) ? '<td class="closed">CLOSED</td>' : '<td></td>';
    row += '</tr>';
    tbody.innerHTML += row;

    // Time rows
    for (let h = sec.start; h < (sec.end === 19 ? 19 : sec.end); h++) {
      let tr = `<tr><td class="time-label">${h}:00 – ${h+1}:00</td>`;
      for (let d = 0; d < 7; d++) {
        const date = new Date(currentMonday); date.setDate(date.getDate() + d);
        if (date.getDay() === 0) { tr += '<td class="closed">CLOSED</td>'; continue; }
        const dateStr = date.toISOString().split('T')[0];
        const timeStr = `${h.toString().padStart(2,'0')}:00`;
        tr += `<td class="time-slot" data-date="${dateStr}" data-time="${timeStr}" onclick="openModal(this)"></td>`;
      }
      tr += '</tr>';
      tbody.innerHTML += tr;
    }
  });

  loadAppointments();
}

async function loadAppointments() {
  const appts = await db.getAll();
  // normalize older data (ensure auto flag exists)
  appts.forEach(a => { if (typeof a.auto === 'undefined') a.auto = true; });

  document.querySelectorAll('.time-slot').forEach(slot => slot.innerHTML = '');
  appts.forEach(appt => {
    // auto-update statuses now (but don't override manual if auto=false)
    autoUpdateStatusFor(appt);

    const cell = document.querySelector(`.time-slot[data-date="${appt.date}"][data-time="${appt.start.split(':')[0]+':00'}"]`);
    if (cell) {
      const div = document.createElement('div');
      div.className = `appt ${appt.status}`;
      div.innerHTML = `<strong>${escapeHtml(appt.name)}</strong><br>${appt.start}–${appt.end}<br><small>${escapeHtml(appt.details||'')}</small>`;
      div.onclick = e => { e.stopPropagation(); editAppt(appt); };
      div.ondblclick = e => { e.stopPropagation(); cycleStatus(appt); };
      cell.appendChild(div);
    }
  });
  scheduleReminders(appts);
}

function scheduleReminders(appts) {
  // cancel existing timeouts? For simplicity we only create them on load (duplicates harmless short-term)
  appts.forEach(appt => {
    if (appt.status === 'red') return;
    const [y,m,d] = appt.date.split('-');
    const [sh, sm] = appt.start.split(':');
    const start = new Date(y, m-1, d, sh, sm);
    const reminder = new Date(start.getTime() - 5*60*1000);
    if (reminder > new Date()) {
      setTimeout(() => {
        if (Notification.permission === "granted") new Notification("5 min Reminder!", { body: `${appt.name} – ${appt.start}–${appt.end}` });
        const audio = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=');
        audio.play().catch(() => {});
      }, reminder - new Date());
    }
  });
}

/* ------------------------
   Auto-status rules
   - default new appt: auto=true
   - if auto true:
       if now > end -> red
       else if start - now <= 60min -> yellow
       else -> green
   - if auto false -> do nothing (manual)
   ------------------------ */
function autoUpdateStatusFor(appt) {
  if (appt.auto === false) return;
  const [y,m,d] = appt.date.split('-');
  const [sh, sm] = appt.start.split(':');
  const [eh, em] = appt.end.split(':');
  const start = new Date(y, m-1, d, sh, sm);
  const end = new Date(y, m-1, d, eh, em);
  const now = new Date();
  if (now > end) appt.status = 'red';
  else if ((start - now) <= 60*60*1000) appt.status = 'yellow';
  else appt.status = 'green';
}

/* Escape for display */
function escapeHtml(s) { return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":"&#39;"}[m])); }

/* =======================
   Modal / editing
   ======================= */
window.openModal = function(el) {
  window.currentDate = el.dataset.date;
  const hour = parseInt(el.dataset.time);
  document.getElementById('editId').value = '';
  document.getElementById('name').value = '';
  document.getElementById('details').value = '';
  document.getElementById('start').value = `${hour.toString().padStart(2,'0')}:00`;
  document.getElementById('end').value = `${(hour+1).toString().padStart(2,'0')}:00`;
  document.getElementById('deleteBtn').style.display = 'none';
  new bootstrap.Modal(document.getElementById('apptModal')).show();
};

window.editAppt = function(appt) {
  document.getElementById('editId').value = appt.id;
  document.getElementById('name').value = appt.name;
  document.getElementById('details').value = appt.details || '';
  document.getElementById('start').value = appt.start;
  document.getElementById('end').value = appt.end;
  document.getElementById('deleteBtn').style.display = 'block';
  window.currentDate = appt.date;
  window.currentAppt = Object.assign({}, appt); // copy
  new bootstrap.Modal(document.getElementById('apptModal')).show();
};

window.cycleStatus = async function(appt) {
  const order = { green: 'yellow', yellow: 'red', red: 'green' };
  appt.status = order[appt.status] || 'green';
  appt.auto = false; // user manually changed status; prevent auto-overwrite
  await db.put(appt);
  loadAppointments();
};

/* =======================
   Save / Delete (with conflict detection)
   ======================= */
document.getElementById('saveBtn').onclick = async () => {
  const id = document.getElementById('editId').value;
  const name = document.getElementById('name').value.trim();
  const start = document.getElementById('start').value;
  const end = document.getElementById('end').value;
  if (!name || !start || !end) return alert('Please fill Customer Name and both times');
  // time validation (end must be after start)
  if (!isEndAfterStart(start, end)) return alert('End time must be after Start time.');

  const details = document.getElementById('details').value.trim();
  const appt = {
    date: window.currentDate,
    name,
    details,
    start,
    end,
    status: id ? (window.currentAppt && window.currentAppt.status ? window.currentAppt.status : 'green') : 'green',
    auto: id ? (window.currentAppt && typeof window.currentAppt.auto !== 'undefined' ? window.currentAppt.auto : true) : true
  };

  if (id) appt.id = Number(id);

  // conflict detection: any overlapping appointments on same date (excluding itself when editing)
  const all = await db.getAll();
  const conflicts = all.filter(a => a.date === appt.date && (!id || a.id !== appt.id) && timesOverlap(a.start, a.end, appt.start, appt.end));

  if (conflicts.length > 0) {
    let msg = 'Conflicting appointments found:\n\n';
    conflicts.forEach(c => msg += `• ${c.name} ${c.start}–${c.end}\n`);
    msg += '\nDo you want to override and save anyway?';
    if (!confirm(msg)) return;
  }

  try {
    if (id) {
      await db.put(appt);
    } else {
      await db.add(appt);
    }
    // Use getOrCreateInstance to ensure hide works
    bootstrap.Modal.getOrCreateInstance(document.getElementById('apptModal')).hide();
    loadAppointments();
  } catch (err) {
    console.error("Save failed:", err);
    alert("Failed to save. Check browser console (F12) for details.");
  }
};

document.getElementById('deleteBtn').onclick = async () => {
  if (confirm('Delete this appointment permanently?')) {
    await db.delete(Number(document.getElementById('editId').value));
    bootstrap.Modal.getOrCreateInstance(document.getElementById('apptModal')).hide();
    loadAppointments();
  }
};

/* Utility: check overlap where times are "HH:MM" strings */
function parseHM(t) { const [h,m]=t.split(':').map(Number); return h*60+m; }
function timesOverlap(s1,e1,s2,e2) {
  const a1 = parseHM(s1), b1 = parseHM(e1), a2 = parseHM(s2), b2 = parseHM(e2);
  return Math.max(a1,a2) < Math.min(b1,b2);
}
function isEndAfterStart(s,e) { return parseHM(e) > parseHM(s); }

/* =======================
   Navigation
   ======================= */
document.getElementById('prev').onclick = () => { currentMonday.setDate(currentMonday.getDate() - 7); renderCalendar(); };
document.getElementById('next').onclick = () => { currentMonday.setDate(currentMonday.getDate() + 7); renderCalendar(); };
document.getElementById('today').onclick = () => { currentMonday = getMonday(new Date()); renderCalendar(); };

/* =======================
   Backup / Restore / Export Week/Month
   - Normal click: full DB backup (existing behavior)
   - Shift+Click: export current week (JSON)
   - Ctrl/Cmd+Click: export current month (JSON)
   ======================= */
function downloadJSON(obj, filename) {
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
}

document.getElementById('backup').onclick = async (ev) => {
  if (ev.shiftKey) {
    // export this week
    const start = new Date(currentMonday);
    const end = new Date(currentMonday.getTime() + 6*24*60*60*1000);
    const data = (await db.getAll()).filter(a => {
      const d = new Date(a.date);
      return d >= start && d <= end;
    });
    downloadJSON(data, `repairshop-week-${start.toISOString().slice(0,10)}.json`);
    return;
  }
  if (ev.ctrlKey || ev.metaKey) {
    // export this month (month containing currentMonday)
    const m = currentMonday.getMonth(), y = currentMonday.getFullYear();
    const data = (await db.getAll()).filter(a => {
      const d = new Date(a.date);
      return d.getFullYear() === y && d.getMonth() === m;
    });
    downloadJSON(data, `repairshop-month-${y}-${String(m+1).padStart(2,'0')}.json`);
    return;
  }
  // default: full DB
  const data = await db.getAll();
  downloadJSON(data, `repairshop-backup-${new Date().toISOString().slice(0,10)}.json`);
};

document.getElementById('restoreBtn').onclick = () => document.getElementById('restore').click();
document.getElementById('restore').onchange = async e => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  const data = JSON.parse(text);
  await db.clear();
  for (const a of data) {
    // keep existing IDs where present — add will respect id if valid
    await db.add(a);
  }
  alert('Backup restored successfully!');
  loadAppointments();
};

/* =======================
   Auto-update loop: every minute, re-evaluate statuses for auto-managed appts
   ======================= */
async function refreshAutoStatuses() {
  const appts = await db.getAll();
  let changed = false;
  appts.forEach(a => {
    const old = a.status;
    autoUpdateStatusFor(a);
    if (a.status !== old) {
      changed = true;
    }
  });
  if (changed) {
    // write back only changed ones
    for (const a of appts) {
      await db.put(a);
    }
    loadAppointments();
  }
}
// run every minute, offset to next minute boundary
setInterval(refreshAutoStatuses, 60*1000);

/* =======================
   Reminders permissions
   ======================= */
if (Notification.permission !== "granted") Notification.requestPermission();

/* =======================
   PWA support (manifest + service worker created inline)
   - Service worker is created via blob URL (no server files required)
   - Install button shown when beforeinstallprompt fires
   ======================= */
const installBtn = document.getElementById('installBtn');
window.addEventListener('beforeinstallprompt', (e) => {
  e.preventDefault();
  deferredInstallPrompt = e;
  installBtn.style.display = 'inline-block';
});
installBtn.addEventListener('click', async () => {
  if (!deferredInstallPrompt) return alert('Install prompt not available.');
  deferredInstallPrompt.prompt();
  const { outcome } = await deferredInstallPrompt.userChoice;
  deferredInstallPrompt = null;
  installBtn.style.display = 'none';
});

/* Inline manifest */
const manifest = {
  name: "Repair Shop Calendar",
  short_name: "RepairShop",
  start_url: ".",
  display: "standalone",
  background_color: "#f8f9fa",
  theme_color: "#343a40",
  icons: []
};
const mr = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
const manifestURL = URL.createObjectURL(mr);
const link = document.createElement('link');
link.rel = 'manifest';
link.href = manifestURL;
document.head.appendChild(link);

/* Service worker code as blob (very simple offline cache) */
if ('serviceWorker' in navigator) {
  const swCode = `
    const CACHE = 'repairshop-v1';
    self.addEventListener('install', e => {
      self.skipWaiting();
      e.waitUntil(caches.open(CACHE).then(c => c.addAll(['/'])).catch(()=>{}));
    });
    self.addEventListener('activate', e => { e.waitUntil(self.clients.claim()); });
    self.addEventListener('fetch', e => {
      if (e.request.method !== 'GET') return;
      e.respondWith(caches.match(e.request).then(r => r || fetch(e.request).then(resp => { try { const copy = resp.clone(); caches.open(CACHE).then(c => c.put(e.request, copy)); } catch(e){} return resp; })));
    });
  `;
  const swBlob = new Blob([swCode], { type: 'text/javascript' });
  const swUrl = URL.createObjectURL(swBlob);
  navigator.serviceWorker.register(swUrl).catch(err => console.warn('SW register failed', err));
}

/* =======================
   Init
   ======================= */
renderCalendar();

// also refresh auto statuses shortly after load
setTimeout(refreshAutoStatuses, 2000);
</script>
</body>
</html>
